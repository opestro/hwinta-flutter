// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'store_integrations.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

StoreIntegrations _$StoreIntegrationsFromJson(Map<String, dynamic> json) {
  return _StoreIntegrations.fromJson(json);
}

/// @nodoc
mixin _$StoreIntegrations {
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;
  MetaPixelIntegration? get metaPixel => throw _privateConstructorUsedError;
  YalidineDeliveryIntegration? get yalidine =>
      throw _privateConstructorUsedError; // @Default({}) Map<String, dynamic> echotrak,
  EchotrakDeliveryIntegration? get echotrak =>
      throw _privateConstructorUsedError;
  ProcolisDeliveryIntegration? get procolis =>
      throw _privateConstructorUsedError;
  NoestDeliveryIntegration? get noest => throw _privateConstructorUsedError;
  Map<String, dynamic>? get googleAnalytics =>
      throw _privateConstructorUsedError;
  GoogleSheetsIntegration? get googleSheet =>
      throw _privateConstructorUsedError;
  Map<String, dynamic>? get sms => throw _privateConstructorUsedError;
  Map<String, dynamic>? get telegram => throw _privateConstructorUsedError;
  Map<String, dynamic>? get maystroDelivery =>
      throw _privateConstructorUsedError;

  /// Serializes this StoreIntegrations to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $StoreIntegrationsCopyWith<StoreIntegrations> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StoreIntegrationsCopyWith<$Res> {
  factory $StoreIntegrationsCopyWith(
          StoreIntegrations value, $Res Function(StoreIntegrations) then) =
      _$StoreIntegrationsCopyWithImpl<$Res, StoreIntegrations>;
  @useResult
  $Res call(
      {Map<String, dynamic>? metadata,
      MetaPixelIntegration? metaPixel,
      YalidineDeliveryIntegration? yalidine,
      EchotrakDeliveryIntegration? echotrak,
      ProcolisDeliveryIntegration? procolis,
      NoestDeliveryIntegration? noest,
      Map<String, dynamic>? googleAnalytics,
      GoogleSheetsIntegration? googleSheet,
      Map<String, dynamic>? sms,
      Map<String, dynamic>? telegram,
      Map<String, dynamic>? maystroDelivery});

  $MetaPixelIntegrationCopyWith<$Res>? get metaPixel;
  $YalidineDeliveryIntegrationCopyWith<$Res>? get yalidine;
  $EchotrakDeliveryIntegrationCopyWith<$Res>? get echotrak;
  $ProcolisDeliveryIntegrationCopyWith<$Res>? get procolis;
  $NoestDeliveryIntegrationCopyWith<$Res>? get noest;
  $GoogleSheetsIntegrationCopyWith<$Res>? get googleSheet;
}

/// @nodoc
class _$StoreIntegrationsCopyWithImpl<$Res, $Val extends StoreIntegrations>
    implements $StoreIntegrationsCopyWith<$Res> {
  _$StoreIntegrationsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
    Object? metaPixel = freezed,
    Object? yalidine = freezed,
    Object? echotrak = freezed,
    Object? procolis = freezed,
    Object? noest = freezed,
    Object? googleAnalytics = freezed,
    Object? googleSheet = freezed,
    Object? sms = freezed,
    Object? telegram = freezed,
    Object? maystroDelivery = freezed,
  }) {
    return _then(_value.copyWith(
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      metaPixel: freezed == metaPixel
          ? _value.metaPixel
          : metaPixel // ignore: cast_nullable_to_non_nullable
              as MetaPixelIntegration?,
      yalidine: freezed == yalidine
          ? _value.yalidine
          : yalidine // ignore: cast_nullable_to_non_nullable
              as YalidineDeliveryIntegration?,
      echotrak: freezed == echotrak
          ? _value.echotrak
          : echotrak // ignore: cast_nullable_to_non_nullable
              as EchotrakDeliveryIntegration?,
      procolis: freezed == procolis
          ? _value.procolis
          : procolis // ignore: cast_nullable_to_non_nullable
              as ProcolisDeliveryIntegration?,
      noest: freezed == noest
          ? _value.noest
          : noest // ignore: cast_nullable_to_non_nullable
              as NoestDeliveryIntegration?,
      googleAnalytics: freezed == googleAnalytics
          ? _value.googleAnalytics
          : googleAnalytics // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      googleSheet: freezed == googleSheet
          ? _value.googleSheet
          : googleSheet // ignore: cast_nullable_to_non_nullable
              as GoogleSheetsIntegration?,
      sms: freezed == sms
          ? _value.sms
          : sms // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      telegram: freezed == telegram
          ? _value.telegram
          : telegram // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      maystroDelivery: freezed == maystroDelivery
          ? _value.maystroDelivery
          : maystroDelivery // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MetaPixelIntegrationCopyWith<$Res>? get metaPixel {
    if (_value.metaPixel == null) {
      return null;
    }

    return $MetaPixelIntegrationCopyWith<$Res>(_value.metaPixel!, (value) {
      return _then(_value.copyWith(metaPixel: value) as $Val);
    });
  }

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $YalidineDeliveryIntegrationCopyWith<$Res>? get yalidine {
    if (_value.yalidine == null) {
      return null;
    }

    return $YalidineDeliveryIntegrationCopyWith<$Res>(_value.yalidine!,
        (value) {
      return _then(_value.copyWith(yalidine: value) as $Val);
    });
  }

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $EchotrakDeliveryIntegrationCopyWith<$Res>? get echotrak {
    if (_value.echotrak == null) {
      return null;
    }

    return $EchotrakDeliveryIntegrationCopyWith<$Res>(_value.echotrak!,
        (value) {
      return _then(_value.copyWith(echotrak: value) as $Val);
    });
  }

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProcolisDeliveryIntegrationCopyWith<$Res>? get procolis {
    if (_value.procolis == null) {
      return null;
    }

    return $ProcolisDeliveryIntegrationCopyWith<$Res>(_value.procolis!,
        (value) {
      return _then(_value.copyWith(procolis: value) as $Val);
    });
  }

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $NoestDeliveryIntegrationCopyWith<$Res>? get noest {
    if (_value.noest == null) {
      return null;
    }

    return $NoestDeliveryIntegrationCopyWith<$Res>(_value.noest!, (value) {
      return _then(_value.copyWith(noest: value) as $Val);
    });
  }

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GoogleSheetsIntegrationCopyWith<$Res>? get googleSheet {
    if (_value.googleSheet == null) {
      return null;
    }

    return $GoogleSheetsIntegrationCopyWith<$Res>(_value.googleSheet!, (value) {
      return _then(_value.copyWith(googleSheet: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$StoreIntegrationsImplCopyWith<$Res>
    implements $StoreIntegrationsCopyWith<$Res> {
  factory _$$StoreIntegrationsImplCopyWith(_$StoreIntegrationsImpl value,
          $Res Function(_$StoreIntegrationsImpl) then) =
      __$$StoreIntegrationsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Map<String, dynamic>? metadata,
      MetaPixelIntegration? metaPixel,
      YalidineDeliveryIntegration? yalidine,
      EchotrakDeliveryIntegration? echotrak,
      ProcolisDeliveryIntegration? procolis,
      NoestDeliveryIntegration? noest,
      Map<String, dynamic>? googleAnalytics,
      GoogleSheetsIntegration? googleSheet,
      Map<String, dynamic>? sms,
      Map<String, dynamic>? telegram,
      Map<String, dynamic>? maystroDelivery});

  @override
  $MetaPixelIntegrationCopyWith<$Res>? get metaPixel;
  @override
  $YalidineDeliveryIntegrationCopyWith<$Res>? get yalidine;
  @override
  $EchotrakDeliveryIntegrationCopyWith<$Res>? get echotrak;
  @override
  $ProcolisDeliveryIntegrationCopyWith<$Res>? get procolis;
  @override
  $NoestDeliveryIntegrationCopyWith<$Res>? get noest;
  @override
  $GoogleSheetsIntegrationCopyWith<$Res>? get googleSheet;
}

/// @nodoc
class __$$StoreIntegrationsImplCopyWithImpl<$Res>
    extends _$StoreIntegrationsCopyWithImpl<$Res, _$StoreIntegrationsImpl>
    implements _$$StoreIntegrationsImplCopyWith<$Res> {
  __$$StoreIntegrationsImplCopyWithImpl(_$StoreIntegrationsImpl _value,
      $Res Function(_$StoreIntegrationsImpl) _then)
      : super(_value, _then);

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? metadata = freezed,
    Object? metaPixel = freezed,
    Object? yalidine = freezed,
    Object? echotrak = freezed,
    Object? procolis = freezed,
    Object? noest = freezed,
    Object? googleAnalytics = freezed,
    Object? googleSheet = freezed,
    Object? sms = freezed,
    Object? telegram = freezed,
    Object? maystroDelivery = freezed,
  }) {
    return _then(_$StoreIntegrationsImpl(
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      metaPixel: freezed == metaPixel
          ? _value.metaPixel
          : metaPixel // ignore: cast_nullable_to_non_nullable
              as MetaPixelIntegration?,
      yalidine: freezed == yalidine
          ? _value.yalidine
          : yalidine // ignore: cast_nullable_to_non_nullable
              as YalidineDeliveryIntegration?,
      echotrak: freezed == echotrak
          ? _value.echotrak
          : echotrak // ignore: cast_nullable_to_non_nullable
              as EchotrakDeliveryIntegration?,
      procolis: freezed == procolis
          ? _value.procolis
          : procolis // ignore: cast_nullable_to_non_nullable
              as ProcolisDeliveryIntegration?,
      noest: freezed == noest
          ? _value.noest
          : noest // ignore: cast_nullable_to_non_nullable
              as NoestDeliveryIntegration?,
      googleAnalytics: freezed == googleAnalytics
          ? _value._googleAnalytics
          : googleAnalytics // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      googleSheet: freezed == googleSheet
          ? _value.googleSheet
          : googleSheet // ignore: cast_nullable_to_non_nullable
              as GoogleSheetsIntegration?,
      sms: freezed == sms
          ? _value._sms
          : sms // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      telegram: freezed == telegram
          ? _value._telegram
          : telegram // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      maystroDelivery: freezed == maystroDelivery
          ? _value._maystroDelivery
          : maystroDelivery // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$StoreIntegrationsImpl extends _StoreIntegrations {
  const _$StoreIntegrationsImpl(
      {final Map<String, dynamic>? metadata = const {},
      this.metaPixel,
      this.yalidine,
      this.echotrak,
      this.procolis,
      this.noest,
      final Map<String, dynamic>? googleAnalytics = const {},
      this.googleSheet,
      final Map<String, dynamic>? sms = const {},
      final Map<String, dynamic>? telegram = const {},
      final Map<String, dynamic>? maystroDelivery = const {}})
      : _metadata = metadata,
        _googleAnalytics = googleAnalytics,
        _sms = sms,
        _telegram = telegram,
        _maystroDelivery = maystroDelivery,
        super._();

  factory _$StoreIntegrationsImpl.fromJson(Map<String, dynamic> json) =>
      _$$StoreIntegrationsImplFromJson(json);

  final Map<String, dynamic>? _metadata;
  @override
  @JsonKey()
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final MetaPixelIntegration? metaPixel;
  @override
  final YalidineDeliveryIntegration? yalidine;
// @Default({}) Map<String, dynamic> echotrak,
  @override
  final EchotrakDeliveryIntegration? echotrak;
  @override
  final ProcolisDeliveryIntegration? procolis;
  @override
  final NoestDeliveryIntegration? noest;
  final Map<String, dynamic>? _googleAnalytics;
  @override
  @JsonKey()
  Map<String, dynamic>? get googleAnalytics {
    final value = _googleAnalytics;
    if (value == null) return null;
    if (_googleAnalytics is EqualUnmodifiableMapView) return _googleAnalytics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  final GoogleSheetsIntegration? googleSheet;
  final Map<String, dynamic>? _sms;
  @override
  @JsonKey()
  Map<String, dynamic>? get sms {
    final value = _sms;
    if (value == null) return null;
    if (_sms is EqualUnmodifiableMapView) return _sms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _telegram;
  @override
  @JsonKey()
  Map<String, dynamic>? get telegram {
    final value = _telegram;
    if (value == null) return null;
    if (_telegram is EqualUnmodifiableMapView) return _telegram;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final Map<String, dynamic>? _maystroDelivery;
  @override
  @JsonKey()
  Map<String, dynamic>? get maystroDelivery {
    final value = _maystroDelivery;
    if (value == null) return null;
    if (_maystroDelivery is EqualUnmodifiableMapView) return _maystroDelivery;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'StoreIntegrations(metadata: $metadata, metaPixel: $metaPixel, yalidine: $yalidine, echotrak: $echotrak, procolis: $procolis, noest: $noest, googleAnalytics: $googleAnalytics, googleSheet: $googleSheet, sms: $sms, telegram: $telegram, maystroDelivery: $maystroDelivery)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StoreIntegrationsImpl &&
            const DeepCollectionEquality().equals(other._metadata, _metadata) &&
            (identical(other.metaPixel, metaPixel) ||
                other.metaPixel == metaPixel) &&
            (identical(other.yalidine, yalidine) ||
                other.yalidine == yalidine) &&
            (identical(other.echotrak, echotrak) ||
                other.echotrak == echotrak) &&
            (identical(other.procolis, procolis) ||
                other.procolis == procolis) &&
            (identical(other.noest, noest) || other.noest == noest) &&
            const DeepCollectionEquality()
                .equals(other._googleAnalytics, _googleAnalytics) &&
            (identical(other.googleSheet, googleSheet) ||
                other.googleSheet == googleSheet) &&
            const DeepCollectionEquality().equals(other._sms, _sms) &&
            const DeepCollectionEquality().equals(other._telegram, _telegram) &&
            const DeepCollectionEquality()
                .equals(other._maystroDelivery, _maystroDelivery));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_metadata),
      metaPixel,
      yalidine,
      echotrak,
      procolis,
      noest,
      const DeepCollectionEquality().hash(_googleAnalytics),
      googleSheet,
      const DeepCollectionEquality().hash(_sms),
      const DeepCollectionEquality().hash(_telegram),
      const DeepCollectionEquality().hash(_maystroDelivery));

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StoreIntegrationsImplCopyWith<_$StoreIntegrationsImpl> get copyWith =>
      __$$StoreIntegrationsImplCopyWithImpl<_$StoreIntegrationsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$StoreIntegrationsImplToJson(
      this,
    );
  }
}

abstract class _StoreIntegrations extends StoreIntegrations {
  const factory _StoreIntegrations(
      {final Map<String, dynamic>? metadata,
      final MetaPixelIntegration? metaPixel,
      final YalidineDeliveryIntegration? yalidine,
      final EchotrakDeliveryIntegration? echotrak,
      final ProcolisDeliveryIntegration? procolis,
      final NoestDeliveryIntegration? noest,
      final Map<String, dynamic>? googleAnalytics,
      final GoogleSheetsIntegration? googleSheet,
      final Map<String, dynamic>? sms,
      final Map<String, dynamic>? telegram,
      final Map<String, dynamic>? maystroDelivery}) = _$StoreIntegrationsImpl;
  const _StoreIntegrations._() : super._();

  factory _StoreIntegrations.fromJson(Map<String, dynamic> json) =
      _$StoreIntegrationsImpl.fromJson;

  @override
  Map<String, dynamic>? get metadata;
  @override
  MetaPixelIntegration? get metaPixel;
  @override
  YalidineDeliveryIntegration?
      get yalidine; // @Default({}) Map<String, dynamic> echotrak,
  @override
  EchotrakDeliveryIntegration? get echotrak;
  @override
  ProcolisDeliveryIntegration? get procolis;
  @override
  NoestDeliveryIntegration? get noest;
  @override
  Map<String, dynamic>? get googleAnalytics;
  @override
  GoogleSheetsIntegration? get googleSheet;
  @override
  Map<String, dynamic>? get sms;
  @override
  Map<String, dynamic>? get telegram;
  @override
  Map<String, dynamic>? get maystroDelivery;

  /// Create a copy of StoreIntegrations
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StoreIntegrationsImplCopyWith<_$StoreIntegrationsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MetaPixelIntegration _$MetaPixelIntegrationFromJson(Map<String, dynamic> json) {
  return _MetaPixelIntegration.fromJson(json);
}

/// @nodoc
mixin _$MetaPixelIntegration {
  String get id => throw _privateConstructorUsedError;
  List<MetaPixel> get pixels => throw _privateConstructorUsedError;
  bool get active => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  /// Serializes this MetaPixelIntegration to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MetaPixelIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MetaPixelIntegrationCopyWith<MetaPixelIntegration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetaPixelIntegrationCopyWith<$Res> {
  factory $MetaPixelIntegrationCopyWith(MetaPixelIntegration value,
          $Res Function(MetaPixelIntegration) then) =
      _$MetaPixelIntegrationCopyWithImpl<$Res, MetaPixelIntegration>;
  @useResult
  $Res call(
      {String id,
      List<MetaPixel> pixels,
      bool active,
      Map<String, dynamic> metadata});
}

/// @nodoc
class _$MetaPixelIntegrationCopyWithImpl<$Res,
        $Val extends MetaPixelIntegration>
    implements $MetaPixelIntegrationCopyWith<$Res> {
  _$MetaPixelIntegrationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MetaPixelIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? pixels = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      pixels: null == pixels
          ? _value.pixels
          : pixels // ignore: cast_nullable_to_non_nullable
              as List<MetaPixel>,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MetaPixelIntegrationImplCopyWith<$Res>
    implements $MetaPixelIntegrationCopyWith<$Res> {
  factory _$$MetaPixelIntegrationImplCopyWith(_$MetaPixelIntegrationImpl value,
          $Res Function(_$MetaPixelIntegrationImpl) then) =
      __$$MetaPixelIntegrationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      List<MetaPixel> pixels,
      bool active,
      Map<String, dynamic> metadata});
}

/// @nodoc
class __$$MetaPixelIntegrationImplCopyWithImpl<$Res>
    extends _$MetaPixelIntegrationCopyWithImpl<$Res, _$MetaPixelIntegrationImpl>
    implements _$$MetaPixelIntegrationImplCopyWith<$Res> {
  __$$MetaPixelIntegrationImplCopyWithImpl(_$MetaPixelIntegrationImpl _value,
      $Res Function(_$MetaPixelIntegrationImpl) _then)
      : super(_value, _then);

  /// Create a copy of MetaPixelIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? pixels = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_$MetaPixelIntegrationImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      pixels: null == pixels
          ? _value._pixels
          : pixels // ignore: cast_nullable_to_non_nullable
              as List<MetaPixel>,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MetaPixelIntegrationImpl extends _MetaPixelIntegration {
  const _$MetaPixelIntegrationImpl(
      {this.id = 'default',
      final List<MetaPixel> pixels = const [],
      this.active = true,
      final Map<String, dynamic> metadata = const {}})
      : _pixels = pixels,
        _metadata = metadata,
        super._();

  factory _$MetaPixelIntegrationImpl.fromJson(Map<String, dynamic> json) =>
      _$$MetaPixelIntegrationImplFromJson(json);

  @override
  @JsonKey()
  final String id;
  final List<MetaPixel> _pixels;
  @override
  @JsonKey()
  List<MetaPixel> get pixels {
    if (_pixels is EqualUnmodifiableListView) return _pixels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_pixels);
  }

  @override
  @JsonKey()
  final bool active;
  final Map<String, dynamic> _metadata;
  @override
  @JsonKey()
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  @override
  String toString() {
    return 'MetaPixelIntegration(id: $id, pixels: $pixels, active: $active, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MetaPixelIntegrationImpl &&
            (identical(other.id, id) || other.id == id) &&
            const DeepCollectionEquality().equals(other._pixels, _pixels) &&
            (identical(other.active, active) || other.active == active) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      const DeepCollectionEquality().hash(_pixels),
      active,
      const DeepCollectionEquality().hash(_metadata));

  /// Create a copy of MetaPixelIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MetaPixelIntegrationImplCopyWith<_$MetaPixelIntegrationImpl>
      get copyWith =>
          __$$MetaPixelIntegrationImplCopyWithImpl<_$MetaPixelIntegrationImpl>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MetaPixelIntegrationImplToJson(
      this,
    );
  }
}

abstract class _MetaPixelIntegration extends MetaPixelIntegration {
  const factory _MetaPixelIntegration(
      {final String id,
      final List<MetaPixel> pixels,
      final bool active,
      final Map<String, dynamic> metadata}) = _$MetaPixelIntegrationImpl;
  const _MetaPixelIntegration._() : super._();

  factory _MetaPixelIntegration.fromJson(Map<String, dynamic> json) =
      _$MetaPixelIntegrationImpl.fromJson;

  @override
  String get id;
  @override
  List<MetaPixel> get pixels;
  @override
  bool get active;
  @override
  Map<String, dynamic> get metadata;

  /// Create a copy of MetaPixelIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MetaPixelIntegrationImplCopyWith<_$MetaPixelIntegrationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

MetaPixel _$MetaPixelFromJson(Map<String, dynamic> json) {
  return _MetaPixel.fromJson(json);
}

/// @nodoc
mixin _$MetaPixel {
  String get id => throw _privateConstructorUsedError;
  String? get key => throw _privateConstructorUsedError;

  /// Serializes this MetaPixel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of MetaPixel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MetaPixelCopyWith<MetaPixel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetaPixelCopyWith<$Res> {
  factory $MetaPixelCopyWith(MetaPixel value, $Res Function(MetaPixel) then) =
      _$MetaPixelCopyWithImpl<$Res, MetaPixel>;
  @useResult
  $Res call({String id, String? key});
}

/// @nodoc
class _$MetaPixelCopyWithImpl<$Res, $Val extends MetaPixel>
    implements $MetaPixelCopyWith<$Res> {
  _$MetaPixelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MetaPixel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? key = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MetaPixelImplCopyWith<$Res>
    implements $MetaPixelCopyWith<$Res> {
  factory _$$MetaPixelImplCopyWith(
          _$MetaPixelImpl value, $Res Function(_$MetaPixelImpl) then) =
      __$$MetaPixelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String? key});
}

/// @nodoc
class __$$MetaPixelImplCopyWithImpl<$Res>
    extends _$MetaPixelCopyWithImpl<$Res, _$MetaPixelImpl>
    implements _$$MetaPixelImplCopyWith<$Res> {
  __$$MetaPixelImplCopyWithImpl(
      _$MetaPixelImpl _value, $Res Function(_$MetaPixelImpl) _then)
      : super(_value, _then);

  /// Create a copy of MetaPixel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? key = freezed,
  }) {
    return _then(_$MetaPixelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MetaPixelImpl extends _MetaPixel {
  const _$MetaPixelImpl({required this.id, this.key}) : super._();

  factory _$MetaPixelImpl.fromJson(Map<String, dynamic> json) =>
      _$$MetaPixelImplFromJson(json);

  @override
  final String id;
  @override
  final String? key;

  @override
  String toString() {
    return 'MetaPixel(id: $id, key: $key)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MetaPixelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.key, key) || other.key == key));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, key);

  /// Create a copy of MetaPixel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MetaPixelImplCopyWith<_$MetaPixelImpl> get copyWith =>
      __$$MetaPixelImplCopyWithImpl<_$MetaPixelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MetaPixelImplToJson(
      this,
    );
  }
}

abstract class _MetaPixel extends MetaPixel {
  const factory _MetaPixel({required final String id, final String? key}) =
      _$MetaPixelImpl;
  const _MetaPixel._() : super._();

  factory _MetaPixel.fromJson(Map<String, dynamic> json) =
      _$MetaPixelImpl.fromJson;

  @override
  String get id;
  @override
  String? get key;

  /// Create a copy of MetaPixel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MetaPixelImplCopyWith<_$MetaPixelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

YalidineDeliveryIntegration _$YalidineDeliveryIntegrationFromJson(
    Map<String, dynamic> json) {
  return _YalidineDeliveryIntegration.fromJson(json);
}

/// @nodoc
mixin _$YalidineDeliveryIntegration {
  String get id => throw _privateConstructorUsedError;
  String get token => throw _privateConstructorUsedError;
  bool get active => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  /// Serializes this YalidineDeliveryIntegration to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of YalidineDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $YalidineDeliveryIntegrationCopyWith<YalidineDeliveryIntegration>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $YalidineDeliveryIntegrationCopyWith<$Res> {
  factory $YalidineDeliveryIntegrationCopyWith(
          YalidineDeliveryIntegration value,
          $Res Function(YalidineDeliveryIntegration) then) =
      _$YalidineDeliveryIntegrationCopyWithImpl<$Res,
          YalidineDeliveryIntegration>;
  @useResult
  $Res call(
      {String id, String token, bool active, Map<String, dynamic> metadata});
}

/// @nodoc
class _$YalidineDeliveryIntegrationCopyWithImpl<$Res,
        $Val extends YalidineDeliveryIntegration>
    implements $YalidineDeliveryIntegrationCopyWith<$Res> {
  _$YalidineDeliveryIntegrationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of YalidineDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? token = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$YalidineDeliveryIntegrationImplCopyWith<$Res>
    implements $YalidineDeliveryIntegrationCopyWith<$Res> {
  factory _$$YalidineDeliveryIntegrationImplCopyWith(
          _$YalidineDeliveryIntegrationImpl value,
          $Res Function(_$YalidineDeliveryIntegrationImpl) then) =
      __$$YalidineDeliveryIntegrationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id, String token, bool active, Map<String, dynamic> metadata});
}

/// @nodoc
class __$$YalidineDeliveryIntegrationImplCopyWithImpl<$Res>
    extends _$YalidineDeliveryIntegrationCopyWithImpl<$Res,
        _$YalidineDeliveryIntegrationImpl>
    implements _$$YalidineDeliveryIntegrationImplCopyWith<$Res> {
  __$$YalidineDeliveryIntegrationImplCopyWithImpl(
      _$YalidineDeliveryIntegrationImpl _value,
      $Res Function(_$YalidineDeliveryIntegrationImpl) _then)
      : super(_value, _then);

  /// Create a copy of YalidineDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? token = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_$YalidineDeliveryIntegrationImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$YalidineDeliveryIntegrationImpl extends _YalidineDeliveryIntegration {
  const _$YalidineDeliveryIntegrationImpl(
      {required this.id,
      required this.token,
      this.active = true,
      final Map<String, dynamic> metadata = const {}})
      : _metadata = metadata,
        super._();

  factory _$YalidineDeliveryIntegrationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$YalidineDeliveryIntegrationImplFromJson(json);

  @override
  final String id;
  @override
  final String token;
  @override
  @JsonKey()
  final bool active;
  final Map<String, dynamic> _metadata;
  @override
  @JsonKey()
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  @override
  String toString() {
    return 'YalidineDeliveryIntegration(id: $id, token: $token, active: $active, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$YalidineDeliveryIntegrationImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.active, active) || other.active == active) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, token, active,
      const DeepCollectionEquality().hash(_metadata));

  /// Create a copy of YalidineDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$YalidineDeliveryIntegrationImplCopyWith<_$YalidineDeliveryIntegrationImpl>
      get copyWith => __$$YalidineDeliveryIntegrationImplCopyWithImpl<
          _$YalidineDeliveryIntegrationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$YalidineDeliveryIntegrationImplToJson(
      this,
    );
  }
}

abstract class _YalidineDeliveryIntegration
    extends YalidineDeliveryIntegration {
  const factory _YalidineDeliveryIntegration(
      {required final String id,
      required final String token,
      final bool active,
      final Map<String, dynamic> metadata}) = _$YalidineDeliveryIntegrationImpl;
  const _YalidineDeliveryIntegration._() : super._();

  factory _YalidineDeliveryIntegration.fromJson(Map<String, dynamic> json) =
      _$YalidineDeliveryIntegrationImpl.fromJson;

  @override
  String get id;
  @override
  String get token;
  @override
  bool get active;
  @override
  Map<String, dynamic> get metadata;

  /// Create a copy of YalidineDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$YalidineDeliveryIntegrationImplCopyWith<_$YalidineDeliveryIntegrationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EchotrakDeliveryIntegration _$EchotrakDeliveryIntegrationFromJson(
    Map<String, dynamic> json) {
  return _EchotrakDeliveryIntegration.fromJson(json);
}

/// @nodoc
mixin _$EchotrakDeliveryIntegration {
  String get baseUrl => throw _privateConstructorUsedError;
  String get token => throw _privateConstructorUsedError;
  bool get active => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  /// Serializes this EchotrakDeliveryIntegration to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of EchotrakDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EchotrakDeliveryIntegrationCopyWith<EchotrakDeliveryIntegration>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EchotrakDeliveryIntegrationCopyWith<$Res> {
  factory $EchotrakDeliveryIntegrationCopyWith(
          EchotrakDeliveryIntegration value,
          $Res Function(EchotrakDeliveryIntegration) then) =
      _$EchotrakDeliveryIntegrationCopyWithImpl<$Res,
          EchotrakDeliveryIntegration>;
  @useResult
  $Res call(
      {String baseUrl,
      String token,
      bool active,
      Map<String, dynamic> metadata});
}

/// @nodoc
class _$EchotrakDeliveryIntegrationCopyWithImpl<$Res,
        $Val extends EchotrakDeliveryIntegration>
    implements $EchotrakDeliveryIntegrationCopyWith<$Res> {
  _$EchotrakDeliveryIntegrationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EchotrakDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? baseUrl = null,
    Object? token = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_value.copyWith(
      baseUrl: null == baseUrl
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EchotrakDeliveryIntegrationImplCopyWith<$Res>
    implements $EchotrakDeliveryIntegrationCopyWith<$Res> {
  factory _$$EchotrakDeliveryIntegrationImplCopyWith(
          _$EchotrakDeliveryIntegrationImpl value,
          $Res Function(_$EchotrakDeliveryIntegrationImpl) then) =
      __$$EchotrakDeliveryIntegrationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String baseUrl,
      String token,
      bool active,
      Map<String, dynamic> metadata});
}

/// @nodoc
class __$$EchotrakDeliveryIntegrationImplCopyWithImpl<$Res>
    extends _$EchotrakDeliveryIntegrationCopyWithImpl<$Res,
        _$EchotrakDeliveryIntegrationImpl>
    implements _$$EchotrakDeliveryIntegrationImplCopyWith<$Res> {
  __$$EchotrakDeliveryIntegrationImplCopyWithImpl(
      _$EchotrakDeliveryIntegrationImpl _value,
      $Res Function(_$EchotrakDeliveryIntegrationImpl) _then)
      : super(_value, _then);

  /// Create a copy of EchotrakDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? baseUrl = null,
    Object? token = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_$EchotrakDeliveryIntegrationImpl(
      baseUrl: null == baseUrl
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EchotrakDeliveryIntegrationImpl extends _EchotrakDeliveryIntegration {
  const _$EchotrakDeliveryIntegrationImpl(
      {required this.baseUrl,
      required this.token,
      this.active = true,
      final Map<String, dynamic> metadata = const {}})
      : _metadata = metadata,
        super._();

  factory _$EchotrakDeliveryIntegrationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EchotrakDeliveryIntegrationImplFromJson(json);

  @override
  final String baseUrl;
  @override
  final String token;
  @override
  @JsonKey()
  final bool active;
  final Map<String, dynamic> _metadata;
  @override
  @JsonKey()
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  @override
  String toString() {
    return 'EchotrakDeliveryIntegration(baseUrl: $baseUrl, token: $token, active: $active, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EchotrakDeliveryIntegrationImpl &&
            (identical(other.baseUrl, baseUrl) || other.baseUrl == baseUrl) &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.active, active) || other.active == active) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, baseUrl, token, active,
      const DeepCollectionEquality().hash(_metadata));

  /// Create a copy of EchotrakDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EchotrakDeliveryIntegrationImplCopyWith<_$EchotrakDeliveryIntegrationImpl>
      get copyWith => __$$EchotrakDeliveryIntegrationImplCopyWithImpl<
          _$EchotrakDeliveryIntegrationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EchotrakDeliveryIntegrationImplToJson(
      this,
    );
  }
}

abstract class _EchotrakDeliveryIntegration
    extends EchotrakDeliveryIntegration {
  const factory _EchotrakDeliveryIntegration(
      {required final String baseUrl,
      required final String token,
      final bool active,
      final Map<String, dynamic> metadata}) = _$EchotrakDeliveryIntegrationImpl;
  const _EchotrakDeliveryIntegration._() : super._();

  factory _EchotrakDeliveryIntegration.fromJson(Map<String, dynamic> json) =
      _$EchotrakDeliveryIntegrationImpl.fromJson;

  @override
  String get baseUrl;
  @override
  String get token;
  @override
  bool get active;
  @override
  Map<String, dynamic> get metadata;

  /// Create a copy of EchotrakDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EchotrakDeliveryIntegrationImplCopyWith<_$EchotrakDeliveryIntegrationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

GoogleSheetsIntegration _$GoogleSheetsIntegrationFromJson(
    Map<String, dynamic> json) {
  return _GoogleSheetsIntegration.fromJson(json);
}

/// @nodoc
mixin _$GoogleSheetsIntegration {
// the spreadsheet id
  String? get id =>
      throw _privateConstructorUsedError; // name of the sheet (page)
  String? get name =>
      throw _privateConstructorUsedError; // deployment id (google apps script)
  String? get deploymentId => throw _privateConstructorUsedError;
  bool get active => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  /// Serializes this GoogleSheetsIntegration to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of GoogleSheetsIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $GoogleSheetsIntegrationCopyWith<GoogleSheetsIntegration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GoogleSheetsIntegrationCopyWith<$Res> {
  factory $GoogleSheetsIntegrationCopyWith(GoogleSheetsIntegration value,
          $Res Function(GoogleSheetsIntegration) then) =
      _$GoogleSheetsIntegrationCopyWithImpl<$Res, GoogleSheetsIntegration>;
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? deploymentId,
      bool active,
      Map<String, dynamic> metadata});
}

/// @nodoc
class _$GoogleSheetsIntegrationCopyWithImpl<$Res,
        $Val extends GoogleSheetsIntegration>
    implements $GoogleSheetsIntegrationCopyWith<$Res> {
  _$GoogleSheetsIntegrationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of GoogleSheetsIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? deploymentId = freezed,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      deploymentId: freezed == deploymentId
          ? _value.deploymentId
          : deploymentId // ignore: cast_nullable_to_non_nullable
              as String?,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GoogleSheetsIntegrationImplCopyWith<$Res>
    implements $GoogleSheetsIntegrationCopyWith<$Res> {
  factory _$$GoogleSheetsIntegrationImplCopyWith(
          _$GoogleSheetsIntegrationImpl value,
          $Res Function(_$GoogleSheetsIntegrationImpl) then) =
      __$$GoogleSheetsIntegrationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? deploymentId,
      bool active,
      Map<String, dynamic> metadata});
}

/// @nodoc
class __$$GoogleSheetsIntegrationImplCopyWithImpl<$Res>
    extends _$GoogleSheetsIntegrationCopyWithImpl<$Res,
        _$GoogleSheetsIntegrationImpl>
    implements _$$GoogleSheetsIntegrationImplCopyWith<$Res> {
  __$$GoogleSheetsIntegrationImplCopyWithImpl(
      _$GoogleSheetsIntegrationImpl _value,
      $Res Function(_$GoogleSheetsIntegrationImpl) _then)
      : super(_value, _then);

  /// Create a copy of GoogleSheetsIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? deploymentId = freezed,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_$GoogleSheetsIntegrationImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      deploymentId: freezed == deploymentId
          ? _value.deploymentId
          : deploymentId // ignore: cast_nullable_to_non_nullable
              as String?,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$GoogleSheetsIntegrationImpl implements _GoogleSheetsIntegration {
  _$GoogleSheetsIntegrationImpl(
      {this.id,
      this.name,
      this.deploymentId,
      this.active = true,
      final Map<String, dynamic> metadata = const {}})
      : _metadata = metadata;

  factory _$GoogleSheetsIntegrationImpl.fromJson(Map<String, dynamic> json) =>
      _$$GoogleSheetsIntegrationImplFromJson(json);

// the spreadsheet id
  @override
  final String? id;
// name of the sheet (page)
  @override
  final String? name;
// deployment id (google apps script)
  @override
  final String? deploymentId;
  @override
  @JsonKey()
  final bool active;
  final Map<String, dynamic> _metadata;
  @override
  @JsonKey()
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  @override
  String toString() {
    return 'GoogleSheetsIntegration(id: $id, name: $name, deploymentId: $deploymentId, active: $active, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GoogleSheetsIntegrationImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.deploymentId, deploymentId) ||
                other.deploymentId == deploymentId) &&
            (identical(other.active, active) || other.active == active) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, deploymentId, active,
      const DeepCollectionEquality().hash(_metadata));

  /// Create a copy of GoogleSheetsIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GoogleSheetsIntegrationImplCopyWith<_$GoogleSheetsIntegrationImpl>
      get copyWith => __$$GoogleSheetsIntegrationImplCopyWithImpl<
          _$GoogleSheetsIntegrationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$GoogleSheetsIntegrationImplToJson(
      this,
    );
  }
}

abstract class _GoogleSheetsIntegration implements GoogleSheetsIntegration {
  factory _GoogleSheetsIntegration(
      {final String? id,
      final String? name,
      final String? deploymentId,
      final bool active,
      final Map<String, dynamic> metadata}) = _$GoogleSheetsIntegrationImpl;

  factory _GoogleSheetsIntegration.fromJson(Map<String, dynamic> json) =
      _$GoogleSheetsIntegrationImpl.fromJson;

// the spreadsheet id
  @override
  String? get id; // name of the sheet (page)
  @override
  String? get name; // deployment id (google apps script)
  @override
  String? get deploymentId;
  @override
  bool get active;
  @override
  Map<String, dynamic> get metadata;

  /// Create a copy of GoogleSheetsIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GoogleSheetsIntegrationImplCopyWith<_$GoogleSheetsIntegrationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ProcolisDeliveryIntegration _$ProcolisDeliveryIntegrationFromJson(
    Map<String, dynamic> json) {
  return _ProcolisDeliveryIntegration.fromJson(json);
}

/// @nodoc
mixin _$ProcolisDeliveryIntegration {
  String get key => throw _privateConstructorUsedError;
  String get token => throw _privateConstructorUsedError;
  bool get active => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  /// Serializes this ProcolisDeliveryIntegration to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ProcolisDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProcolisDeliveryIntegrationCopyWith<ProcolisDeliveryIntegration>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProcolisDeliveryIntegrationCopyWith<$Res> {
  factory $ProcolisDeliveryIntegrationCopyWith(
          ProcolisDeliveryIntegration value,
          $Res Function(ProcolisDeliveryIntegration) then) =
      _$ProcolisDeliveryIntegrationCopyWithImpl<$Res,
          ProcolisDeliveryIntegration>;
  @useResult
  $Res call(
      {String key, String token, bool active, Map<String, dynamic> metadata});
}

/// @nodoc
class _$ProcolisDeliveryIntegrationCopyWithImpl<$Res,
        $Val extends ProcolisDeliveryIntegration>
    implements $ProcolisDeliveryIntegrationCopyWith<$Res> {
  _$ProcolisDeliveryIntegrationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProcolisDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? token = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_value.copyWith(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProcolisDeliveryIntegrationImplCopyWith<$Res>
    implements $ProcolisDeliveryIntegrationCopyWith<$Res> {
  factory _$$ProcolisDeliveryIntegrationImplCopyWith(
          _$ProcolisDeliveryIntegrationImpl value,
          $Res Function(_$ProcolisDeliveryIntegrationImpl) then) =
      __$$ProcolisDeliveryIntegrationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String key, String token, bool active, Map<String, dynamic> metadata});
}

/// @nodoc
class __$$ProcolisDeliveryIntegrationImplCopyWithImpl<$Res>
    extends _$ProcolisDeliveryIntegrationCopyWithImpl<$Res,
        _$ProcolisDeliveryIntegrationImpl>
    implements _$$ProcolisDeliveryIntegrationImplCopyWith<$Res> {
  __$$ProcolisDeliveryIntegrationImplCopyWithImpl(
      _$ProcolisDeliveryIntegrationImpl _value,
      $Res Function(_$ProcolisDeliveryIntegrationImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProcolisDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? token = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_$ProcolisDeliveryIntegrationImpl(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ProcolisDeliveryIntegrationImpl extends _ProcolisDeliveryIntegration {
  const _$ProcolisDeliveryIntegrationImpl(
      {required this.key,
      required this.token,
      this.active = true,
      final Map<String, dynamic> metadata = const {}})
      : _metadata = metadata,
        super._();

  factory _$ProcolisDeliveryIntegrationImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$ProcolisDeliveryIntegrationImplFromJson(json);

  @override
  final String key;
  @override
  final String token;
  @override
  @JsonKey()
  final bool active;
  final Map<String, dynamic> _metadata;
  @override
  @JsonKey()
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  @override
  String toString() {
    return 'ProcolisDeliveryIntegration(key: $key, token: $token, active: $active, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProcolisDeliveryIntegrationImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.active, active) || other.active == active) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, key, token, active,
      const DeepCollectionEquality().hash(_metadata));

  /// Create a copy of ProcolisDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProcolisDeliveryIntegrationImplCopyWith<_$ProcolisDeliveryIntegrationImpl>
      get copyWith => __$$ProcolisDeliveryIntegrationImplCopyWithImpl<
          _$ProcolisDeliveryIntegrationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ProcolisDeliveryIntegrationImplToJson(
      this,
    );
  }
}

abstract class _ProcolisDeliveryIntegration
    extends ProcolisDeliveryIntegration {
  const factory _ProcolisDeliveryIntegration(
      {required final String key,
      required final String token,
      final bool active,
      final Map<String, dynamic> metadata}) = _$ProcolisDeliveryIntegrationImpl;
  const _ProcolisDeliveryIntegration._() : super._();

  factory _ProcolisDeliveryIntegration.fromJson(Map<String, dynamic> json) =
      _$ProcolisDeliveryIntegrationImpl.fromJson;

  @override
  String get key;
  @override
  String get token;
  @override
  bool get active;
  @override
  Map<String, dynamic> get metadata;

  /// Create a copy of ProcolisDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProcolisDeliveryIntegrationImplCopyWith<_$ProcolisDeliveryIntegrationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

NoestDeliveryIntegration _$NoestDeliveryIntegrationFromJson(
    Map<String, dynamic> json) {
  return _NoestDeliveryIntegration.fromJson(json);
}

/// @nodoc
mixin _$NoestDeliveryIntegration {
  String get guid => throw _privateConstructorUsedError;
  String get token => throw _privateConstructorUsedError;
  bool get active => throw _privateConstructorUsedError;
  Map<String, dynamic> get metadata => throw _privateConstructorUsedError;

  /// Serializes this NoestDeliveryIntegration to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of NoestDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NoestDeliveryIntegrationCopyWith<NoestDeliveryIntegration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NoestDeliveryIntegrationCopyWith<$Res> {
  factory $NoestDeliveryIntegrationCopyWith(NoestDeliveryIntegration value,
          $Res Function(NoestDeliveryIntegration) then) =
      _$NoestDeliveryIntegrationCopyWithImpl<$Res, NoestDeliveryIntegration>;
  @useResult
  $Res call(
      {String guid, String token, bool active, Map<String, dynamic> metadata});
}

/// @nodoc
class _$NoestDeliveryIntegrationCopyWithImpl<$Res,
        $Val extends NoestDeliveryIntegration>
    implements $NoestDeliveryIntegrationCopyWith<$Res> {
  _$NoestDeliveryIntegrationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NoestDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? guid = null,
    Object? token = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_value.copyWith(
      guid: null == guid
          ? _value.guid
          : guid // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NoestDeliveryIntegrationImplCopyWith<$Res>
    implements $NoestDeliveryIntegrationCopyWith<$Res> {
  factory _$$NoestDeliveryIntegrationImplCopyWith(
          _$NoestDeliveryIntegrationImpl value,
          $Res Function(_$NoestDeliveryIntegrationImpl) then) =
      __$$NoestDeliveryIntegrationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String guid, String token, bool active, Map<String, dynamic> metadata});
}

/// @nodoc
class __$$NoestDeliveryIntegrationImplCopyWithImpl<$Res>
    extends _$NoestDeliveryIntegrationCopyWithImpl<$Res,
        _$NoestDeliveryIntegrationImpl>
    implements _$$NoestDeliveryIntegrationImplCopyWith<$Res> {
  __$$NoestDeliveryIntegrationImplCopyWithImpl(
      _$NoestDeliveryIntegrationImpl _value,
      $Res Function(_$NoestDeliveryIntegrationImpl) _then)
      : super(_value, _then);

  /// Create a copy of NoestDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? guid = null,
    Object? token = null,
    Object? active = null,
    Object? metadata = null,
  }) {
    return _then(_$NoestDeliveryIntegrationImpl(
      guid: null == guid
          ? _value.guid
          : guid // ignore: cast_nullable_to_non_nullable
              as String,
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      active: null == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool,
      metadata: null == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$NoestDeliveryIntegrationImpl extends _NoestDeliveryIntegration {
  const _$NoestDeliveryIntegrationImpl(
      {required this.guid,
      required this.token,
      this.active = true,
      final Map<String, dynamic> metadata = const {}})
      : _metadata = metadata,
        super._();

  factory _$NoestDeliveryIntegrationImpl.fromJson(Map<String, dynamic> json) =>
      _$$NoestDeliveryIntegrationImplFromJson(json);

  @override
  final String guid;
  @override
  final String token;
  @override
  @JsonKey()
  final bool active;
  final Map<String, dynamic> _metadata;
  @override
  @JsonKey()
  Map<String, dynamic> get metadata {
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_metadata);
  }

  @override
  String toString() {
    return 'NoestDeliveryIntegration(guid: $guid, token: $token, active: $active, metadata: $metadata)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NoestDeliveryIntegrationImpl &&
            (identical(other.guid, guid) || other.guid == guid) &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.active, active) || other.active == active) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, guid, token, active,
      const DeepCollectionEquality().hash(_metadata));

  /// Create a copy of NoestDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NoestDeliveryIntegrationImplCopyWith<_$NoestDeliveryIntegrationImpl>
      get copyWith => __$$NoestDeliveryIntegrationImplCopyWithImpl<
          _$NoestDeliveryIntegrationImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$NoestDeliveryIntegrationImplToJson(
      this,
    );
  }
}

abstract class _NoestDeliveryIntegration extends NoestDeliveryIntegration {
  const factory _NoestDeliveryIntegration(
      {required final String guid,
      required final String token,
      final bool active,
      final Map<String, dynamic> metadata}) = _$NoestDeliveryIntegrationImpl;
  const _NoestDeliveryIntegration._() : super._();

  factory _NoestDeliveryIntegration.fromJson(Map<String, dynamic> json) =
      _$NoestDeliveryIntegrationImpl.fromJson;

  @override
  String get guid;
  @override
  String get token;
  @override
  bool get active;
  @override
  Map<String, dynamic> get metadata;

  /// Create a copy of NoestDeliveryIntegration
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NoestDeliveryIntegrationImplCopyWith<_$NoestDeliveryIntegrationImpl>
      get copyWith => throw _privateConstructorUsedError;
}
